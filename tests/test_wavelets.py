import os
# import sys
import unittest
import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path

from tirex.utils.filters import WaveletFilter
from tirex.utils.ewt import EmpiricalWaveletTransform
from tirex.utils.plot import save_plot, decomp_plot
from tests import unit_test_plots_path

unit_test_wavelet_plots_path = (unit_test_plots_path / 'wavelet').resolve()
unit_test_wavelet_plots_path.mkdir(parents=True, exist_ok=True)


def generate_synthetic_data(length: int = 10000, noise_level: float = 0.1) -> (np.ndarray, np.ndarray):

    x = np.linspace(0., 300., length)

    y_base = np.sin(x / 10.)
    y_main = 12. * noise_level * np.cumsum(np.random.random(length)-0.5)

    y_noisy = y_base + y_main
    y_noisy += 1.2 * (np.abs(y_noisy)).max()

    return x, 100. * y_noisy


def test_int_main():

    x, y_noisy = generate_synthetic_data()

    wavelet_filter = WaveletFilter(wavelet='db4')
    # wavelet_filter = WaveletFilter(wavelet='sym4')

    white_noise_removed = wavelet_filter.remove_white_noise(y_noisy)

    plot_fname = f"{unit_test_wavelet_plots_path}/white_noise_removal.png"
    save_plot(x, y_noisy, white_noise_removed, "White Noise Removal", plot_fname)

    denoised_signal = wavelet_filter.denoise(y_noisy)
    save_plot(x, y_noisy, denoised_signal, "Denoising", "denoising.png")

    for lg_td_i in [3, 4, 5, 6, 7, 8, 9, 12]:
        long_term_trend_signal = wavelet_filter.long_term_trend(y_noisy, level=lg_td_i)
        plot_fname_i = f"{unit_test_wavelet_plots_path}/long_term_trend_lv{lg_td_i}.png"
        save_plot(x, y_noisy, long_term_trend_signal, "Long-term Trend", plot_fname_i)

    # white_noise_signal = wavelet_filter.extract_white_noise(y_noisy)
    # save_plot(x, y_noisy, white_noise_signal, "White Noise Signal", f"white_noise_signal.png")

    dwt_signals = wavelet_filter.decomposition(y_noisy)
    plot_fname_i = f"{unit_test_wavelet_plots_path}/dwt_decomp.png"
    decomp_plot(x, y_noisy, dwt_signals, plot_fname_i)


class TestEWTIntegration(unittest.TestCase):


    @staticmethod
    def _plot(np_x, np_y, np_ewt, file_name):

        num_components = min(np_ewt.shape[1], 8)

        fig, ax = plt.subplots(num_components + 1, 1, figsize=(30, 20), dpi=200)
        ax[0].plot(np_x, np_y, label='Original Signal')
        ax[0].set_title('Original Synthetic Signal')
        ax[0].grid(which='minor', alpha=0.2)
        ax[0].grid(which='major', alpha=0.5)

        # Verify that the sum of the components approximates the original signal
        reconstructed_signal = np_ewt.sum(axis=1)
        ax[0].plot(np_x, reconstructed_signal, "-.", color="red", label='Original Signal')
        ax[0].legend()

        for i in range(num_components):
            ax_i = ax[i + 1]
            ax_i.plot(np_x, np_ewt[:, i])
            ax_i.set_title(f'EWT Component {i + 1}')
            ax_i.grid(which='minor', alpha=0.2)
            ax_i.grid(which='major', alpha=0.5)

        plt.tight_layout()
        fig.savefig(file_name)
        plt.close()

    def test_decompose_synthetic_signal(self):
        """
        Test Explanation:

        - Signal Creation: A synthetic signal is generated by summing sine waves at 5 Hz, 20 Hz, and 50 Hz.
        - The reconstructed signal (sum of the components) is compared to the original signal to ensure they are close.
        - An assertion checks that there are no NaN values in the decomposed components
        """

        # Create a synthetic signal composed of multiple sine waves
        t = np.linspace(0, 1, 1000)
        freq1 = 5  # 5 Hz
        freq2 = 20  # 20 Hz
        freq3 = 50  # 50 Hz

        signal = (np.sin(2 * np.pi * freq1 * t) +
                  np.sin(2 * np.pi * freq2 * t) +
                  np.sin(2 * np.pi * freq3 * t))

        # Initialize EWT
        ewt = EmpiricalWaveletTransform()

        # Decompose the signal
        signal_ft, result, n = ewt.run(signal)
        ewt_components = result['ewt']

        # Limit the number of components to 6
        reconstructed_signal = ewt_components.sum(axis=1)

        # Plot the original signal and decomposed components
        plot_fname = f"{unit_test_wavelet_plots_path}/ewt_decompose_synthetic_signal.png"

        self._plot(t, signal, result['ewt'], plot_fname)

        np.testing.assert_allclose(reconstructed_signal, signal, atol=1e-1)

        # Assert that the EWT components are not NaNs
        self.assertFalse(np.isnan(ewt_components).any())

    def test_decompose_audio_signal(self):
        """
        Test Explanation:

        - Signal Creation: An audio signal is simulated by generating a sine wave at 440 Hz (A4 note)
        - EWT Decomposition: The audio signal is decomposed using EWT.

        Verification:
        - The reconstructed signal is compared with the original audio signal.
        - An assertion ensures there are no NaN values in the components.

        """

        # Load a segment of an audio signal
        # For the test, we'll simulate an audio signal using a sine wave
        fs = 44100  # Sampling frequency
        duration = 1  # seconds
        t = np.linspace(0, duration, int(fs * duration), endpoint=False)
        freq = 440  # A4 note frequency (440 Hz)
        audio_signal = np.sin(2 * np.pi * freq * t)

        # Initialize EWT
        ewt = EmpiricalWaveletTransform()

        # Decompose the audio signal
        signal_ft, result, n = ewt.run(audio_signal)
        ewt_components = result['ewt']

        # Plot the original audio signal and decomposed components
        plot_fname = f"{unit_test_wavelet_plots_path}/ewt_decompose_audio_signal.png"
        self._plot(t, audio_signal, result['ewt'], plot_fname)

        # Verify that the sum of the components approximates the original signal
        reconstructed_signal = ewt_components.sum(axis=1)
        np.testing.assert_allclose(reconstructed_signal, audio_signal, atol=1e-1)

        # Assert that the EWT components are not NaNs
        self.assertFalse(np.isnan(ewt_components).any())

    def test_decompose_noisy_signal(self):
        """
        Test Explanation:

        - Signal Creation: A noisy signal is created by adding Gaussian noise to a 10 Hz sine wave.
        - EWT Decomposition: The noisy signal is decomposed using EWT.

        Verification:
        - The reconstructed signal is compared with the clean signal, using only the first few components to filter out noise.
        - An assertion checks for the absence of NaN values.

        """

        # Create a synthetic signal with noise
        t = np.linspace(0, 1, 1000)
        freq = 10  # 10 Hz
        clean_signal = np.sin(2 * np.pi * freq * t)
        noise = np.random.normal(0, 0.5, t.shape)
        noisy_signal = clean_signal + 0.2 * noise

        # Initialize EWT
        ewt = EmpiricalWaveletTransform()

        # Decompose the noisy signal
        signal_ft, result, n = ewt.run(noisy_signal)
        ewt_components = result['ewt']

        # Plot the original signal and decomposed components
        plot_fname = f"{unit_test_wavelet_plots_path}/ewt_decompose_noisy_signal.png"

        self._plot(t, noisy_signal, result['ewt'], plot_fname)

        # Reconstruct the signal using the first few components
        reconstructed_signal = ewt_components.sum(axis=1)

        # Verify that the reconstructed signal approximates the clean signal
        np.testing.assert_allclose(reconstructed_signal, clean_signal, atol=0.5)

        # Assert that the EWT components are not NaNs
        self.assertFalse(np.isnan(ewt_components).any())

if __name__ == "__main__":
    test_int_main()
